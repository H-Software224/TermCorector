 여기 접근하는데 얘들에 대한 정보는 누가 관리하는지? 페이스테이블들에 대한 정보래요. 운영체제가 관리한다고 했잖아. 그러면 이 운영체제가 관리하고 있는 요 친구들, 요 페이스테이블 등에서 어떤 한 친구에 대해서 접근을 해야 되겠지. 요 접근하는 행위를 어떻게 구현을 할 거냐에 대한 얘기를 더 하는 거예요. 인텔 같은 경우는, 인텔 같은 경우는 하드베어적으로 nmv에다가 nmv에다가 이제 mnv, 하드베어로 구현을 했어. 구현을 해가지고 이게 페이지 테이블에 대한 그 아까 얘기했던 그 시작조 베이스 어드레스에 대한 정보랑 랭스 정보가 어디에 들어가 있냐면 PCD 안에 들어가 있대요. memory access를 한다는 얘기는 지금 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그, 그�란, 랭스 정보가 어디에 들어가 있냐면 PCD 안에 들어가 있대요. 메모리 액세스를 한다는 얘기는 지금 그 메모리을 사용하고 있는 프로세스가 스케쥴링에서 런닝 상태라는 얘기잖아요. 개가 수행이 되면서 개가 지코드를 수행하면서 메모리 액세스를 하는 행위를 할 거라고. 메모리 XS를 하는 행위를 할 거라고. 그러니 당연히 PCB 정보에 있던 것들을 어떻게 다 알고 있는 상태야. 알고 있는 상태인데, 그게 아니고 페이지 테이블에 대한 정보도 있거든. 있는 것을 인텔 같은 경우는 성능을 높이기 위해서 MMU에서 하드웨어 로직으로 구현해서 직방으로 꽉 꽂아서 바로 쓸 수 있고 이렇게 만들고 나고 레지스퍼서 다른 것 써요. 소피아적으로 OS로도 구현을 할 수도 있어. OS한테 명령을 줘서 얘가 소피아적으로 구현을 할 수 있고. 이렇게 만들 수 있는 게 그러면 이렇게 만들면 뭐가 돼? 모드이 스테인지가 되죠. 유저모드에서 그렇게 편한 것도 지니 되겠지. 그래서 턴업코드 로 수행을하는 건 당연히 오버웨이드가 크죠. 얘는 하드웨어로 처리를 하는 거니까 모든 트렌디션 없이 하드웨어로 직접 써가지고 메모리 엑셀, XS 한번 하고, KG정보 가져와서 TFR 업데이트 하고, 다시 한번 하고 돌고 이렇게 인작하는 거니까 편할 모드로 전환을 안 해도 됩니다. 근데 이거를 그 로직으로 하드웨어로 주연하는 걸로 운영체를 따라서 처리할 수 있도록 하면은 부품값이 줄겠지. 근데 성능이 어때? 떨어져. 그래서 얘 써? 안 써. 키의 비가 작잖아요? 최대 48개 정도의 엔트리가 캐싱할 수 있는 친구야. 캐싱하고 있는 엔트리 정보는 현재 런닝 상태인 그 프로세스 한테만 유료하잖아. 맞아요? 굳이. 근데 우리가 사용하고 있는 시스템은 멀티프레임이 적용된 시스템이죠. 그죠? 멀티프레임 타임 케어 림이 적용된 시스템. 이미 앞에 CPU 자원을 배울 때 다 했잖아. 턴텍스트 스위치 인간. A 프로세스가 돌아가고 있었어. TLD도 어쩔지 해가지고 잘 캐싱을 하는 상태에서 히트 히트 해가지고 확 메모리 에세스를 하고 있었어. 그러다가 내가 타입 커턴을 다 썼어. 그래서 레디 상태로 내려오고 스케줄러에 의해서 그 다음에 B라고 하는 프로세스가 올라왔다고요. 그러면 어떻게? TLB는 어떻게 하면 돼요? 어떻게 해야 돼요? 아 그 원래 원본이 있던 그 TMI 정보를 갖다가 그대로 빽 엎어가지고 든다고? 안 그래요? 그게 오버에이드 컷 아무 의미가 없으니까 치워야지 그 원래는 클리어 해줘야 되는데 지금 우리가 배운 페이지 테이블의 �트리가 유효한 정보인지, 더 있는거에요. 그 것들이 쭉 있고. 다음 context switch이 딱 되면 mnu가 자동으로 현재 테이블, ktm 안에 들어가 있는 모든 앱, 패싱되는 암딩, 이전 포스, 사이머드, 엔딩이 있죠. 거기에 적혀져 있는 벨리드, 인벨리드, 미트를 다 인벨리드로 바꿔야죠. 이거 다 무효. 자 그러면 컨택스트 스위치 처음에 짠! 됐어. 한 번 됐다. 되면 얘네 다 인벨리드니까 어떻게 돼? 메모리세스 하기라면 무조건 KCGAME을 참조해야 되잖아. 처음에는 컨텍스트 칠칭을 새로운 코스가 올라왔을 때는 무조건 메모리 엑세스를 두 번 해. 무조건. 무조건 두 번 해. 근데 한 번 하고 나면 그 다음부터는 H��트 리에시가 엄청 높은거지. 그리고 엔트리 하나, 406kb 만큼의 메모니를 가지고 있는 엔트리 하나라는 것까지 그 부분을 표현할 수 있는 엔트리 하나 가져온다고 히트 리에시가 99% 이상이 되나요? 그거로 물어보면 돼. 왜 그런 줄 알아? 프로그램 코드 전체에서, 전체에서 여러분들 작성하는 코드 양으로 맞추세요. 10만 라인으로 맞추세요. 10만 라인 중에서 실제로 실행시켰을 때 수행되는 코드의 핵심적인 코드는 전체 양 중에서 얼마나 이 10만 라인 중에서 얘를 실제로 실행시켰을 때 수행되는 핵심적인 코드는 전체 양 중에서 얼마나 될까요? 20도 위반이 타고요. 반복되는 코드가, 또 올라가지겠네요. 인스트럭션들을 모아놓은 게. 계속 돌다가 다시 올라가고, 돌다가 올라가고, 돌다가 올라가고, 돌다가 올라가고, 계속 그러죠. 한 빼리지 않아서 계속 빼리빼리돈다. 이게 그냥 미니어하게 끝으로 올라가고, 춥 내려오는 코드들은 1회성이야. 거의 한 번 수행되고, 거의 수행이 안 돼. 실질적으로 전체 엑서프션 타임 중에서 실행되는 코드는, 실행되는 인스트밌될 것 같고. 3천%가 빠졌는데. 처음에 컨택스트 스위칭이 되면 TLB는 그 친구를 전부 다 인베넷 비트로 바꾸기 때문에 모든 엔피디에 랜인베넷 비트로 인베넷 비트로 바꾸기 때문에 처음에는 레몬 리스트 앱은 두 번을 하게 될 것 같아요. 두 번을 하면서 TLB 업데이트가 되죠 엔피디가. 새로운 엔피디 업데이트가 되면서부터 TKM가 높아지면서, 해싱이 따뜻해지면서, 골드 상태에서 따따�긴 하지만 한 번이 될 수도 있고 여러번이 될 수도 있고 최초는 무조건 일어나는 거잖아요. 무조건 일어날 수 밖에 없는 거잖아요. 그래서 그 두 번 액세스를 좀 빨리 하면 좋을 것 같지? 빨리하면 좋을 거야. 그걸 통해서 그걸 어떻게 처리를 하냐면, 인터넷 같은 경우는 CR3라고 하는 그 P21BNT기의 시작 지점부터 시작해서, 시작 지점을 가리키는 레지스터가 있어요. 그리고 M&M 안에 추가로 다가가서 컴택스트 스위치가 되고 PC 정보로 백업하는 동안에 페이지 테이블에 있는 일부 정보를 가져다가 넣어줘요. 페이지 테이블에 빨리 액세서리 할 수 있고 탑웨어저로 더 도와주는 그런 것들이 있더라 정도만 의미하면 될 것 같아요. 아 봐봐 이런 코드가 있다고 생각해봐. 코드도 광고도 되지. 맞아? 변수. 아이도 계속 적금하지. 썸도 계속 적금하지.